<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Hello World in Backbone.js</title>
</head>
<body>
  <!-- ========= -->
  <!-- Your HTML -->
  <!-- ========= -->
<form name="myForm">
<p><label>Form name:<input type="text" name="text1" value="Beluga"></label>
<p><input name="button1" type="button" value="Show Form Name"
     onclick="this.form.text1.value = this.form.name">
</p>
</form>
 <div class = "button">
 first button
 </div> 

<div> 
 <form>
  <input id="input" type="text" value="Hello there">
</form>
</div>

<div id="other">
  Trigger the handler
</div>
 <div class = "button">
 second button
 </div>
 
   <div class = "buttons">
 third button
 </div>
 
 
 
  <button id="btn-0">Button 1!</button>
<button id="btn-1">Button 2!</button>
<button id="btn-2">Button 3!</button>

<script type="text/javascript">
    var prizes = ['A Unicorn!', 'A Hug!', 'Fresh Laundry!'];
    for (var btnNum = 0; btnNum < prizes.length; btnNum++) {
        // for each of our buttons, when the user clicks it...
        (function(b){
		document.getElementById('btn-' + b).onclick = function() {
            // tell her what she's won!
            alert(prizes[b]);
        };
		
		})(btnNum);
    }
</script> 
  <!-- ========= -->
  <!-- Libraries -->
  <!-- ========= -->
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js" type="text/javascript"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.9.2/backbone-min.js" type="text/javascript"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/backbone-localstorage.js/1.0/backbone.localStorage-min.js" type="text/javascript"></script>  
  
  <!-- =============== -->
  <!-- Javascript code -->
  <!-- =============== -->
  <script type="text/javascript">
    // your JS code goes here
	
 
function Person(name, age){
	this.name = name;
	this.age = age;	
}

function Car(model, year, owner){
	this.model = model;
	this.year = year;
	this.owner = owner;	
	this.metho = function(a){
		this.year = year + a;	
		
	}
}

var person1 = new Person("ken", 27);
var person2 = new Person("Ann", 18);


var car1 = new Car("benzi", 2016, person1);
console.log(car1.color);
car1.color = "black";
console.log(car1.color);
console.log(car1.owner.age);
car1.metho(1);
console.log(car1.year);




var temp = 0;

var yoshi = (function(){
	var temp = 1;
	console.log(temp);
})();
	
	
	yoshi;
	console.log(temp);
	
car1.door = "closed";
console.log(car1.door);

Car.prototype.door = "closed";
Car.prototype.adding = function(string1, string2){
		this.model = string1 + string2;
}


	
//object literal vs constructor. If it is just a data container user object literal. If there is method use constructor. You 
//ALSO more importantly. Constructor let you create more than one instances, while object literal is like a singleton
//ALSO Constructor way let you have private property/method, but in object literal it is all public
var data = {
	property1: "hi",
	property2: "hi2"	
}

//constructor


function dataa(property3, property4){
	this.property1 = property3;
	this.property2 = property4;
		
	this.add= function(propertyX){
		this.property1 = this.property1 + propertyX;
	}
	
}
//or you can add the .add function using prototype
dataa.prototype.property3 = "newproperty";
d = new dataa("p1", "p2");
d.add("p3");
console.log(d.property1);
console.log(d.property3);



var namespacing = {
	variable1: "hello",
	variable2: "world"	
}

namespacing.variable1 = "world";





///////////////////////////////////name space example:

//bad: 
function calculateVat(prod) {
    return prod.price * 1.21;
}
 
var product = function (price) {
    this.price = price;
    this.getPrice = function(){
                       return this.price;
        };
    };
 
function doCalculations() {
    var p = new product(100);
    alert(calculateVat(p.getPrice()));
}

//better:
var MYAPPLICATION = {
    calculateVat: function (base) {
        return base * 1.21;
    },
    product: function (price) {
        this.price = price;
        this.getPrice = function(){
                          return this.price;
                       };
    },
    doCalculations: function () {
        var p = new MYAPPLICATION.product(100);
        alert(this.calculateVat(p.getPrice()));
    }
}

var p = new MYAPPLICATION.product(150);


//closure
//http://javascriptissexy.com/understand-javascript-closures-with-ease/
function count(i){
	nodes[i].addEventListener('click', function() {
      	console.log('You clicked element #' + i);
	});
}

var nodes = document.getElementsByClassName('button');
console.log(nodes.length);
for (var i = 0; i < nodes.length; i++) {
	count(i);
	
}

console.log(mul(2)(3)(4));
function mul(n){
	return function (x){
		return function (y){
			return n * x * y;	
		}
		
	}
}

var output = (function(x){
    delete x;
    return x;
  })(0);

  console.log(output);
  
  
  
 //////////////////////////// the second one is defined in run time, second one is parse time
 function test(){
	 
 }
 
 var test = function(){
	 
 }
 //////////////////////////
//////////////////////////////////////////////////////////////example:

test();
var test = function(){} //error


test();
function test(){} //ok


var vari = "hi";
var foo = function test2(){
	vari = "yoshi";	
}
foo();
console.log(vari);






//wrong 
function f1() {
	var a = 1;
	f2();
}

function f2(){
	return a;	
}

//ANSWER: function vs block scope
//Functions can access the variables in same scope in which they are "DEFINED" and NOT "CALLED"]



//right
function f1() {
	var a = 1;
	function f2(){
	return a;	
	}
	
	return f2();
}

console.log(f1());



for (var i = 0; i < 5; i++) {
	(function() {
    	setTimeout(function() { console.log(i); }, i * 1000 );
    })();
}









var globalVar = "xyz";

(function outerFunc(outerArg) {
  var outerVar = 'a';
  
  (function innerFunc(innerArg) {
    var innerVar = 'b';
    

	  
	  (function inmore(tom){
		      console.log(
      "outerArg = " + outerArg + "\n" +
      "innerArg = " + innerArg + "\n" +
      "outerVar = " + outerVar + "\n" +
      "innerVar = " + innerVar + "\n" +
      "globalVar = " + globalVar);
		  
	  })(500);
	  
    
  })(456);
})(123);


//javascript hoisting

  var text = 'outside';
function logIt(){
    console.log(text);
    var text = 'inside';
};
logIt();

//is actually

var text = 'outside';
function logIt(){
    var test;
	console.log(text);
    text = 'inside';
};
logIt();










gob = "hi";

(function(){
	console.log(gob);
	var gob = "world";
	console.log(gob);
	
	
})();






function getSize(object){
    var count = 0;
    for(key in object){
      // hasOwnProperty method check own property of object
      if(object.hasOwnProperty(key)) count++;
    }
    return count;
}



 
console.log(this.music); //'classical' (global)
 
console.log(foo()); 



//what THIS refer to depend on who invoked the function. for example
var name = "ann";

function foolish(){
	// "this" inside this function will have the value of the window object​
    // because the showFullName () function is defined in the global scope, just like the firstName and lastName​
		console.log(name); 
		
}


    // We have a simple object with a clickHandler method that we want to use when a button on the page is clicked​
    var user = {
    data: ([{name:"T. Woods", age:37}, {name:"P. Mickelson", age:43}]),
    
		clickHandler:function (event) {
			
			var randomNum = ((Math.random () * 2 | 0) + 1) - 1;
			
			console.log (self.data[randomNum].name + " " + self.data[randomNum].age);
		}
    }
    $ (".buttons").click (user.clickHandler);




//we can use bind to fix this problem


  $ (".buttons").click (user.clickHandler.bind(user));


$(document).ready(function() {
    
	var count = 0;
	
	$('#input').keydown(function() {
      count++;
    });
	
	$('input').keyup(function(){
		window.setTimeout(function(){
			count--;	
			if (count == 0){					
					console.log("ajax call, send to server");
			}
		}, 2000);	
	});
});





function Mammal(name){ 
	this.name=name;
	this.offspring=[];
} 
Mammal.prototype.haveABaby=function(){ 
	var newBaby=new Mammal("Baby "+this.name);
	this.offspring.push(newBaby);
	return newBaby;
} 
Mammal.prototype.toString=function(){ 
	return '[Mammal "'+this.name+'"]';
} 

var firstMammal = new Mammal("marcus");

firstMammal.haveABaby();
firstMammal.haveABaby();
console.log("start");
console.log(firstMammal.toString());
console.log(firstMammal.offspring[1].toString());


Cat.prototype = new Mammal();        // Here's where the inheritance occurs 
Cat.prototype.constructor=Cat;       // Otherwise instances of Cat would have a constructor of Mammal 
function Cat(name){ 
	this.name=name;
} 
Cat.prototype.toString=function(){ 
	return '[Cat "'+this.name+'"]';
} 

//Every object instance in JS has a property named constructor that points to its parent class. For example, someAnimal.constructor==Mammmal is true. Armed with this knowledge, we can remake the haveABaby() method like this:

Mammal.prototype.haveABaby=function(){ 
	var newBaby=new this.constructor("Baby "+this.name);
	this.offspring.push(newBaby);
	return newBaby;
} 

//CONSTRUCTOR VS PROTOTYPE
//http://thecodeship.com/web-development/methods-within-constructor-vs-prototype-in-javascript/

  </script>
  

  
</body>
</html>